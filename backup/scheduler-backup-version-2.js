// T·ªëi ∆∞u file scheduler.js
const axios = require("axios");
const schedule = require("node-schedule");
const kiotviet = require("./kiotviet");
const invoiceScanner = require("./invoiceScanner");
const lark = require("./lark");
const path = require("path");
const fs = require("fs");

// ƒê∆∞·ªùng d·∫´n ƒë·∫øn th∆∞ m·ª•c l∆∞u tr·ªØ d·ªØ li·ªáu ƒë∆°n h√†ng theo ng√†y
const DATA_DIR = path.resolve(process.cwd(), "data");
// ƒê∆∞·ªùng d·∫´n ƒë·∫øn file l∆∞u tr·ªØ th√¥ng tin t·ªïng h·ª£p
const ORDERS_SUMMARY_FILE = path.resolve(DATA_DIR, "orders_summary.json");
// ƒê∆∞·ªùng d·∫´n ƒë·∫øn file l∆∞u tr·ªØ danh s√°ch ƒë∆°n h√†ng (v·∫´n gi·ªØ ƒë·ªÉ t∆∞∆°ng th√≠ch ng∆∞·ª£c)
const ORDERS_FILE_PATH = path.resolve(process.cwd(), "lastOrders.json");
exports.ORDERS_FILE_PATH = ORDERS_FILE_PATH;

function setupPeriodicCheck() {
  if (!fs.existsSync(DATA_DIR)) {
    fs.mkdirSync(DATA_DIR, { recursive: true });
    console.log(`üìÇ ƒê√£ t·∫°o th∆∞ m·ª•c d·ªØ li·ªáu: ${DATA_DIR}`);
  }

  setTimeout(async () => {
    try {
      console.log("üîÑ Ch·∫°y ki·ªÉm tra ban ƒë·∫ßu...");
      await runReportNow();
    } catch (error) {
      console.error("‚ùå L·ªói trong qu√° tr√¨nh ki·ªÉm tra ban ƒë·∫ßu:", error.message);
    }
  }, 5000);

  const interval = setInterval(async () => {
    try {
      console.log(
        `\n--- üïí Ki·ªÉm tra ƒë·ªãnh k·ª≥ l√∫c ${new Date().toLocaleTimeString()} ---`
      );

      // L·∫•y v√† l∆∞u ƒë∆°n h√†ng trong 14 ng√†y
      await fetchAndStoreOrdersForLast14Days();

      // L·∫•y danh s√°ch h√≥a ƒë∆°n hi·ªán t·∫°i
      const currentInvoices = await invoiceScanner.getRecentInvoices();
      console.log(`üìä ƒê√£ l·∫•y ${currentInvoices.length} h√≥a ƒë∆°n t·ª´ KiotViet`);

      // L·∫•y t·∫•t c·∫£ c√°c ƒë∆°n h√†ng ƒë√£ l∆∞u
      const allSavedOrders = await getAllSavedOrders();
      console.log(
        `üìä ƒê√£ t·∫£i ${allSavedOrders.length} ƒë∆°n h√†ng ƒë√£ l∆∞u ƒë·ªÉ so s√°nh`
      );

      // L·ªçc c√°c ƒë∆°n h√†ng ·ªü tr·∫°ng th√°i h·ª£p l·ªá
      const validOrders = allSavedOrders.filter(
        (order) =>
          order.status === 1 || order.status === 2 || order.status === 3
      );
      console.log(
        `üîç ƒê√£ l·ªçc ${validOrders.length} ƒë∆°n h√†ng v·ªõi tr·∫°ng th√°i h·ª£p l·ªá t·ª´ d·ªØ li·ªáu ƒë√£ l∆∞u`
      );

      // So s√°nh ƒë∆°n h√†ng v·ªõi h√≥a ƒë∆°n
      const orderInvoiceComparisons = compareOrdersWithInvoices(
        validOrders,
        currentInvoices
      );

      // G·ª≠i th√¥ng b√°o cho c√°c so s√°nh c√≥ s·ª± kh√°c bi·ªát
      if (orderInvoiceComparisons.length > 0) {
        console.log(
          `üîî T√¨m th·∫•y ${orderInvoiceComparisons.length} ƒë∆°n h√†ng c√≥ s·ª± kh√°c bi·ªát so v·ªõi h√≥a ƒë∆°n`
        );

        for (const comparison of orderInvoiceComparisons) {
          try {
            await lark.sendOrderInvoiceComparisonReport(comparison);
            console.log(
              `‚úÖ ƒê√£ g·ª≠i b√°o c√°o so s√°nh cho ƒë∆°n h√†ng ${comparison.order.code} v√† h√≥a ƒë∆°n ${comparison.invoice.code}`
            );
          } catch (err) {
            console.error(
              `‚ùå L·ªói g·ª≠i b√°o c√°o so s√°nh cho ƒë∆°n h√†ng ${comparison.order.code}:`,
              err.message
            );
          }
        }
      } else {
        console.log("‚úÖ Kh√¥ng t√¨m th·∫•y s·ª± kh√°c bi·ªát gi·ªØa ƒë∆°n h√†ng v√† h√≥a ƒë∆°n");
      }

      // So s√°nh h√≥a ƒë∆°n g·ªëc v·ªõi c√°c phi√™n b·∫£n ƒëi·ªÅu ch·ªânh
      const invoiceVersionComparisons = compareInvoiceVersions(currentInvoices);

      // G·ª≠i th√¥ng b√°o cho c√°c so s√°nh c√≥ s·ª± kh√°c bi·ªát
      if (invoiceVersionComparisons.length > 0) {
        console.log(
          `üîî T√¨m th·∫•y ${invoiceVersionComparisons.length} h√≥a ƒë∆°n ƒëi·ªÅu ch·ªânh c√≥ s·ª± kh√°c bi·ªát`
        );

        for (const comparison of invoiceVersionComparisons) {
          try {
            await lark.sendInvoiceVersionComparisonReport(comparison);
            console.log(
              `‚úÖ ƒê√£ g·ª≠i b√°o c√°o so s√°nh cho h√≥a ƒë∆°n ${comparison.originalInvoice.code} v√† phi√™n b·∫£n ƒëi·ªÅu ch·ªânh ${comparison.revisedInvoice.code}`
            );
          } catch (err) {
            console.error(
              `‚ùå L·ªói g·ª≠i b√°o c√°o so s√°nh cho h√≥a ƒë∆°n ${comparison.originalInvoice.code}:`,
              err.message
            );
          }
        }
      } else {
        console.log(
          "‚úÖ Kh√¥ng t√¨m th·∫•y s·ª± kh√°c bi·ªát gi·ªØa c√°c phi√™n b·∫£n h√≥a ƒë∆°n"
        );
      }

      // C·∫≠p nh·∫≠t file lastOrders.json ƒë·ªÉ t∆∞∆°ng th√≠ch ng∆∞·ª£c
      saveCurrentData(validOrders);
    } catch (error) {
      console.error("‚ùå L·ªói trong qu√° tr√¨nh ki·ªÉm tra ƒë·ªãnh k·ª≥:", error.message);
    }
  }, 15000);

  return {
    stop: () => clearInterval(interval),
  };
}

/**
 * L·∫•y v√† l∆∞u ƒë∆°n h√†ng cho 14 ng√†y g·∫ßn nh·∫•t
 */
async function fetchAndStoreOrdersForLast14Days() {
  try {
    console.log("üîÑ B·∫Øt ƒë·∫ßu t·∫£i v√† l∆∞u ƒë∆°n h√†ng trong 14 ng√†y g·∫ßn ƒë√¢y");

    // T·∫°o danh s√°ch 14 ng√†y g·∫ßn nh·∫•t
    const days = [];
    for (let i = 0; i < 14; i++) {
      const date = new Date();
      date.setDate(date.getDate() - i);
      days.push(date);
    }

    // T·∫£i th√¥ng tin t√≥m t·∫Øt t·ª´ file n·∫øu c√≥
    let summary = {
      lastProcessedDays: {},
      lastUpdate: new Date().toISOString(),
    };
    if (fs.existsSync(ORDERS_SUMMARY_FILE)) {
      try {
        const data = fs.readFileSync(ORDERS_SUMMARY_FILE, "utf8");
        summary = JSON.parse(data);
      } catch (err) {
        console.error(`‚ùå L·ªói ƒë·ªçc file t·ªïng h·ª£p: ${err.message}`);
      }
    }

    let allOrdersCount = 0;

    // Duy·ªát qua t·ª´ng ng√†y
    for (const day of days) {
      const dateStr = day.toISOString().split("T")[0]; // ƒê·ªãnh d·∫°ng YYYY-MM-DD
      const filePath = path.resolve(DATA_DIR, `orders_${dateStr}.json`);

      // Ki·ªÉm tra xem ng√†y n√†y ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω ƒë·∫ßy ƒë·ªß ch∆∞a
      const dayKey = day.toISOString().split("T")[0];
      const dayProcessed = summary.lastProcessedDays[dayKey];

      // N·∫øu ng√†y n√†y ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω ƒë·∫ßy ƒë·ªß v√† file t·ªìn t·∫°i, b·ªè qua
      if (dayProcessed && fs.existsSync(filePath)) {
        console.log(`üìÖ Ng√†y ${dateStr} ƒë√£ ƒë∆∞·ª£c x·ª≠ l√Ω ƒë·∫ßy ƒë·ªß, b·ªè qua`);
        allOrdersCount += dayProcessed.count || 0;
        continue;
      }

      console.log(`üîç ƒêang x·ª≠ l√Ω ƒë∆°n h√†ng cho ng√†y: ${dateStr}`);

      // L·∫•y ƒë∆°n h√†ng cho ng√†y n√†y
      const orders = await getOrdersForDay(day);
      console.log(`üìä ƒê√£ l·∫•y ${orders.length} ƒë∆°n h√†ng cho ${dateStr}`);

      if (orders.length > 0) {
        // ƒê·∫£m b·∫£o th∆∞ m·ª•c t·ªìn t·∫°i
        if (!fs.existsSync(DATA_DIR)) {
          fs.mkdirSync(DATA_DIR, { recursive: true });
        }

        // L·ªçc ƒë∆°n h√†ng ·ªü tr·∫°ng th√°i ph√π h·ª£p
        const validOrders = orders.filter(
          (order) =>
            order.status === 1 || order.status === 2 || order.status === 3
        );

        console.log(
          `üìù L∆∞u ${validOrders.length} ƒë∆°n h√†ng h·ª£p l·ªá cho ${dateStr}`
        );

        // L∆∞u v√†o file cho ng√†y c·ª• th·ªÉ
        fs.writeFileSync(
          filePath,
          JSON.stringify(validOrders, null, 2),
          "utf8"
        );

        // C·∫≠p nh·∫≠t th√¥ng tin t√≥m t·∫Øt
        summary.lastProcessedDays[dayKey] = {
          processed: true,
          count: validOrders.length,
          validCount: validOrders.length,
          originalCount: orders.length,
          lastUpdate: new Date().toISOString(),
        };

        allOrdersCount += validOrders.length;
      } else {
        console.log(`‚ÑπÔ∏è Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng cho ${dateStr}`);
        // ƒê√°nh d·∫•u ƒë√£ x·ª≠ l√Ω nh∆∞ng kh√¥ng c√≥ d·ªØ li·ªáu
        summary.lastProcessedDays[dayKey] = {
          processed: true,
          count: 0,
          validCount: 0,
          originalCount: 0,
          lastUpdate: new Date().toISOString(),
        };
      }

      // L∆∞u th√¥ng tin t√≥m t·∫Øt
      summary.lastUpdate = new Date().toISOString();
      fs.writeFileSync(
        ORDERS_SUMMARY_FILE,
        JSON.stringify(summary, null, 2),
        "utf8"
      );

      // Tr√°nh gi·ªõi h·∫°n t·ªëc ƒë·ªô API
      await new Promise((resolve) => setTimeout(resolve, 500));
    }

    console.log(
      `‚úÖ Ho√†n th√†nh vi·ªác t·∫£i v√† l∆∞u ƒë∆°n h√†ng, t·ªïng c·ªông ${allOrdersCount} ƒë∆°n h√†ng h·ª£p l·ªá trong 14 ng√†y`
    );

    // C·∫≠p nh·∫≠t file lastOrders.json
    const allSavedOrders = await getAllSavedOrders();
    saveCurrentData(allSavedOrders);
  } catch (error) {
    console.error("‚ùå L·ªói t·∫£i v√† l∆∞u ƒë∆°n h√†ng trong 14 ng√†y:", error.message);
    throw error;
  }
}

/**
 * L·∫•y ƒë∆°n h√†ng cho m·ªôt ng√†y c·ª• th·ªÉ
 */
async function getOrdersForDay(date) {
  try {
    const token = await kiotviet.getToken();

    // T√≠nh to√°n 7 ng√†y tr∆∞·ªõc
    const sevenDaysAgo = new Date();
    sevenDaysAgo.setDate(sevenDaysAgo.getDate() - 7);

    // ƒê·ªãnh d·∫°ng ng√†y
    const fromDateStr = sevenDaysAgo.toISOString();
    const toDateStr = new Date().toISOString();

    console.log(`üîç L·∫•y ƒë∆°n h√†ng t·ª´ ${fromDateStr} ƒë·∫øn ${toDateStr}`);

    // Bi·∫øn ph√¢n trang
    let currentItem = 0;
    let hasMoreData = true;
    let allOrders = [];
    const pageSize = 100;

    // L·∫•y t·∫•t c·∫£ ƒë∆°n h√†ng
    while (hasMoreData) {
      const response = await axios.get(`${process.env.KIOT_BASE_URL}/orders`, {
        params: {
          fromCreatedDate: fromDateStr,
          toCreatedDate: toDateStr,
          pageSize: pageSize,
          currentItem: currentItem,
          orderBy: "createdDate",
          orderDirection: "DESC",
          includeOrderDelivery: true,
        },
        headers: {
          Retailer: process.env.KIOT_SHOP_NAME,
          Authorization: `Bearer ${token}`,
        },
      });

      const orders = response.data.data || [];
      allOrders = allOrders.concat(orders);

      console.log(
        `üìä L·∫•y ƒë∆∞·ª£c ${orders.length} ƒë∆°n h√†ng, t·ªïng s·ªë: ${allOrders.length}`
      );

      // Ki·ªÉm tra xem c√≤n d·ªØ li·ªáu kh√¥ng
      if (orders.length < pageSize) {
        hasMoreData = false;
      } else {
        currentItem += pageSize;
      }

      // Tr√°nh gi·ªõi h·∫°n t·ªëc ƒë·ªô API
      if (hasMoreData) {
        await new Promise((resolve) => setTimeout(resolve, 1000));
      }
    }

    // Lo·∫°i b·ªè tr√πng l·∫∑p v√† l·ªçc theo tr·∫°ng th√°i
    const uniqueOrders = Array.from(
      new Map(allOrders.map((order) => [order.id, order])).values()
    );

    // L·ªçc theo tr·∫°ng th√°i (1: Phi·∫øu t·∫°m, 2: ƒê√£ x√°c nh·∫≠n, 3: ƒê√£ h·ªßy)
    const validOrders = uniqueOrders.filter((order) =>
      [1, 2, 3].includes(order.status)
    );

    console.log(
      `‚úÖ ƒê√£ l·ªçc ƒë∆∞·ª£c ${validOrders.length} ƒë∆°n h√†ng h·ª£p l·ªá t·ª´ ${uniqueOrders.length} ƒë∆°n h√†ng duy nh·∫•t`
    );

    return validOrders;
  } catch (error) {
    console.error("‚ùå L·ªói khi l·∫•y ƒë∆°n h√†ng g·∫ßn ƒë√¢y:", error.message);
    if (error.response) {
      console.error(
        "Chi ti·∫øt l·ªói:",
        error.response.status,
        error.response.data
      );
    }
    return [];
  }
}

/**
 * L·∫•y t·∫•t c·∫£ ƒë∆°n h√†ng ƒë√£ l∆∞u trong 14 ng√†y
 */
async function getAllSavedOrders() {
  try {
    const allOrders = [];

    // T·∫°o danh s√°ch 14 ng√†y g·∫ßn nh·∫•t
    for (let i = 0; i < 14; i++) {
      const date = new Date();
      date.setDate(date.getDate() - i);
      const dateStr = date.toISOString().split("T")[0]; // ƒê·ªãnh d·∫°ng YYYY-MM-DD
      const filePath = path.resolve(DATA_DIR, `orders_${dateStr}.json`);

      if (fs.existsSync(filePath)) {
        try {
          const data = fs.readFileSync(filePath, "utf8");
          const orders = JSON.parse(data);
          console.log(`üìä ƒê√£ t·∫£i ${orders.length} ƒë∆°n h√†ng t·ª´ ${dateStr}`);
          allOrders.push(...orders);
        } catch (err) {
          console.error(`‚ùå L·ªói ƒë·ªçc file ${filePath}: ${err.message}`);
        }
      }
    }

    // Lo·∫°i b·ªè tr√πng l·∫∑p
    const uniqueOrders = [];
    const orderIdSet = new Set();

    for (const order of allOrders) {
      if (order && order.id && !orderIdSet.has(order.id)) {
        orderIdSet.add(order.id);
        uniqueOrders.push(order);
      }
    }

    console.log(
      `üìä T·ªïng s·ªë ƒë∆°n h√†ng duy nh·∫•t t·ª´ t·∫•t c·∫£ c√°c ng√†y: ${uniqueOrders.length}`
    );
    return uniqueOrders;
  } catch (error) {
    console.error("‚ùå L·ªói khi l·∫•y t·∫•t c·∫£ ƒë∆°n h√†ng ƒë√£ l∆∞u:", error.message);
    return [];
  }
}

/**
 * L·∫•y danh s√°ch h√≥a ƒë∆°n g·∫ßn ƒë√¢y
 */

/**
 * L∆∞u ƒë∆°n h√†ng v√†o file lastOrders.json ƒë·ªÉ t∆∞∆°ng th√≠ch ng∆∞·ª£c
 */
function saveCurrentData(orders) {
  try {
    // Ki·ªÉm tra ƒë·∫ßu v√†o
    if (!orders) {
      console.error("‚ùå Kh√¥ng c√≥ d·ªØ li·ªáu ƒë∆°n h√†ng ƒë·ªÉ l∆∞u");
      return;
    }

    if (!Array.isArray(orders)) {
      console.error("‚ùå D·ªØ li·ªáu ƒë∆°n h√†ng kh√¥ng ph·∫£i l√† m·∫£ng");
      return;
    }

    // ƒê·∫£m b·∫£o th∆∞ m·ª•c t·ªìn t·∫°i
    const dirPath = path.dirname(ORDERS_FILE_PATH);
    if (!fs.existsSync(dirPath)) {
      try {
        fs.mkdirSync(dirPath, { recursive: true });
        console.log(`üìÇ T·∫°o th∆∞ m·ª•c: ${dirPath}`);
      } catch (mkdirError) {
        console.error("‚ùå L·ªói t·∫°o th∆∞ m·ª•c:", mkdirError);
        return;
      }
    }

    // Lo·∫°i b·ªè c√°c ƒë∆°n h√†ng tr√πng l·∫∑p d·ª±a tr√™n ID
    const uniqueOrders = Array.from(
      new Map(orders.map((order) => [order.id, order])).values()
    );

    // L·ªçc ch·ªâ l·∫•y c√°c ƒë∆°n h√†ng ·ªü tr·∫°ng th√°i ph√π h·ª£p
    const validOrders = uniqueOrders.filter(
      (order) => order.status === 1 || order.status === 2 || order.status === 3
    );

    console.log(
      `üîç ƒê√£ l·ªçc ${validOrders.length} ƒë∆°n h√†ng h·ª£p l·ªá t·ª´ ${uniqueOrders.length} ƒë∆°n h√†ng duy nh·∫•t`
    );

    // Chu·∫©n b·ªã d·ªØ li·ªáu ƒë·ªÉ l∆∞u
    const dataToSave = {
      timestamp: new Date().toISOString(),
      totalOrders: validOrders.length,
      orders: validOrders,
    };

    // Ghi file
    try {
      fs.writeFileSync(
        ORDERS_FILE_PATH,
        JSON.stringify(dataToSave, null, 2),
        "utf8"
      );

      console.log(
        `üíæ ƒê√£ l∆∞u ${validOrders.length} ƒë∆°n h√†ng duy nh·∫•t v√†o ${ORDERS_FILE_PATH}`
      );
    } catch (writeError) {
      console.error("‚ùå L·ªói ghi file:", writeError);

      // Th·ª≠ ghi l·∫°i v·ªõi quy·ªÅn cao h∆°n n·∫øu c·∫ßn
      try {
        fs.chmodSync(ORDERS_FILE_PATH, 0o666);
        fs.writeFileSync(
          ORDERS_FILE_PATH,
          JSON.stringify(dataToSave, null, 2),
          "utf8"
        );
        console.log("‚úÖ ƒê√£ ghi file th√†nh c√¥ng sau khi ƒëi·ªÅu ch·ªânh quy·ªÅn");
      } catch (rechmodError) {
        console.error(
          "‚ùå Kh√¥ng th·ªÉ ghi file ngay c·∫£ sau khi ƒëi·ªÅu ch·ªânh quy·ªÅn:",
          rechmodError
        );
      }
    }
  } catch (error) {
    console.error("‚ùå L·ªói kh√¥ng mong ƒë·ª£i trong qu√° tr√¨nh l∆∞u d·ªØ li·ªáu:", error);
    console.error("Chi ti·∫øt l·ªói:", error.stack);
  }
}

/**
 * So s√°nh ƒë∆°n h√†ng v·ªõi h√≥a ƒë∆°n
 */
function compareOrdersWithInvoices(orders, invoices) {
  try {
    const comparisons = [];

    // L·ªçc ra c√°c h√≥a ƒë∆°n g·ªëc (kh√¥ng c√≥ h·∫≠u t·ªë .0x)
    const originalInvoices = invoices.filter((invoice) => {
      const code = invoice.code || "";
      return !code.match(/\.\d+$/);
    });

    console.log(
      `üîç T√¨m th·∫•y ${originalInvoices.length} h√≥a ƒë∆°n g·ªëc ƒë·ªÉ so s√°nh v·ªõi ƒë∆°n h√†ng`
    );

    // Duy·ªát qua t·ª´ng ƒë∆°n h√†ng
    for (const order of orders) {
      // T√¨m h√≥a ƒë∆°n g·ªëc c√≥ c√πng m√£ v·ªõi ƒë∆°n h√†ng
      const matchingInvoice = originalInvoices.find(
        (invoice) => invoice.orderCode === order.code
      );

      if (matchingInvoice) {
        // So s√°nh chi ti·∫øt gi·ªØa ƒë∆°n h√†ng v√† h√≥a ƒë∆°n
        const differences = compareOrderAndInvoiceDetails(
          order,
          matchingInvoice
        );

        if (differences.hasChanges) {
          comparisons.push({
            order,
            invoice: matchingInvoice,
            differences,
          });
        }
      }
    }

    console.log(
      `üîç T√¨m th·∫•y ${comparisons.length} c·∫∑p ƒë∆°n h√†ng-h√≥a ƒë∆°n c√≥ s·ª± kh√°c bi·ªát`
    );
    return comparisons;
  } catch (error) {
    console.error("‚ùå L·ªói khi so s√°nh ƒë∆°n h√†ng v·ªõi h√≥a ƒë∆°n:", error.message);
    return [];
  }
}

/**
 * So s√°nh chi ti·∫øt gi·ªØa ƒë∆°n h√†ng v√† h√≥a ƒë∆°n
 */
function compareOrderAndInvoiceDetails(order, invoice) {
  try {
    const comparison = {
      addedProducts: [], // S·∫£n ph·∫©m c√≥ trong h√≥a ƒë∆°n nh∆∞ng kh√¥ng c√≥ trong ƒë∆°n h√†ng
      removedProducts: [], // S·∫£n ph·∫©m c√≥ trong ƒë∆°n h√†ng nh∆∞ng kh√¥ng c√≥ trong h√≥a ƒë∆°n
      quantityChanges: [], // S·∫£n ph·∫©m c√≥ thay ƒë·ªïi s·ªë l∆∞·ª£ng
      hasChanges: false, // ƒê√°nh d·∫•u c√≥ s·ª± kh√°c bi·ªát
    };

    // Ki·ªÉm tra n·∫øu kh√¥ng c√≥ chi ti·∫øt ƒë∆°n h√†ng ho·∫∑c h√≥a ƒë∆°n
    if (!order.orderDetails || !invoice.invoiceDetails) {
      return comparison;
    }

    // T·∫°o map t·ª´ chi ti·∫øt ƒë∆°n h√†ng
    const orderDetailsMap = new Map();
    order.orderDetails.forEach((detail) => {
      if (detail.productId) {
        orderDetailsMap.set(detail.productId, detail);
      }
    });

    // T·∫°o map t·ª´ chi ti·∫øt h√≥a ƒë∆°n
    const invoiceDetailsMap = new Map();
    invoice.invoiceDetails.forEach((detail) => {
      if (detail.productId) {
        invoiceDetailsMap.set(detail.productId, detail);
      }
    });

    // Ki·ªÉm tra s·∫£n ph·∫©m th√™m m·ªõi
    for (const [productId, invoiceDetail] of invoiceDetailsMap) {
      if (!orderDetailsMap.has(productId)) {
        comparison.addedProducts.push(invoiceDetail);
        comparison.hasChanges = true;
      }
    }

    // Ki·ªÉm tra s·∫£n ph·∫©m b·ªã x√≥a
    for (const [productId, orderDetail] of orderDetailsMap) {
      if (!invoiceDetailsMap.has(productId)) {
        comparison.removedProducts.push(orderDetail);
        comparison.hasChanges = true;
      }
    }

    // Ki·ªÉm tra s·∫£n ph·∫©m thay ƒë·ªïi s·ªë l∆∞·ª£ng
    for (const [productId, invoiceDetail] of invoiceDetailsMap) {
      if (orderDetailsMap.has(productId)) {
        const orderDetail = orderDetailsMap.get(productId);
        if (invoiceDetail.quantity !== orderDetail.quantity) {
          comparison.quantityChanges.push({
            product: invoiceDetail,
            orderQuantity: orderDetail.quantity,
            invoiceQuantity: invoiceDetail.quantity,
            difference: invoiceDetail.quantity - orderDetail.quantity,
          });
          comparison.hasChanges = true;
        }
      }
    }

    return comparison;
  } catch (error) {
    console.error(
      "‚ùå L·ªói khi so s√°nh chi ti·∫øt ƒë∆°n h√†ng v√† h√≥a ƒë∆°n:",
      error.message
    );
    return { hasChanges: false };
  }
}
exports.compareOrderAndInvoiceDetails = compareOrderAndInvoiceDetails;

/**
 * So s√°nh c√°c phi√™n b·∫£n h√≥a ƒë∆°n
 */
function compareInvoiceVersions(invoices) {
  try {
    const comparisons = [];

    // T√¨m t·∫•t c·∫£ c√°c h√≥a ƒë∆°n c√≥ m√£ d·∫°ng .0x
    const revisedInvoices = invoices.filter((invoice) => {
      const code = invoice.code || "";
      return code.match(/\.\d+$/);
    });

    console.log(
      `üîç T√¨m th·∫•y ${revisedInvoices.length} h√≥a ƒë∆°n ƒë√£ ƒëi·ªÅu ch·ªânh (ƒë·ªãnh d·∫°ng .0x)`
    );

    // Duy·ªát qua t·ª´ng h√≥a ƒë∆°n ƒë√£ ƒëi·ªÅu ch·ªânh
    for (const revisedInvoice of revisedInvoices) {
      // Tr√≠ch xu·∫•t th√¥ng tin v·ªÅ phi√™n b·∫£n v√† m√£ g·ªëc
      const versionInfo = extractInvoiceVersion(revisedInvoice.code);

      if (versionInfo.isRevised) {
        // T√¨m h√≥a ƒë∆°n g·ªëc
        const originalInvoice = invoices.find(
          (invoice) => invoice.code === versionInfo.baseCode
        );

        if (originalInvoice) {
          // So s√°nh chi ti·∫øt gi·ªØa h√≥a ƒë∆°n g·ªëc v√† h√≥a ƒë∆°n ƒë√£ ƒëi·ªÅu ch·ªânh
          const differences = compareInvoiceDetails(
            originalInvoice,
            revisedInvoice
          );

          if (differences.hasChanges) {
            comparisons.push({
              originalInvoice,
              revisedInvoice,
              differences,
              versionInfo,
            });
          }
        }
      }
    }

    console.log(
      `üîç T√¨m th·∫•y ${comparisons.length} c·∫∑p phi√™n b·∫£n h√≥a ƒë∆°n c√≥ s·ª± kh√°c bi·ªát`
    );
    return comparisons;
  } catch (error) {
    console.error("‚ùå L·ªói khi so s√°nh c√°c phi√™n b·∫£n h√≥a ƒë∆°n:", error.message);
    return [];
  }
}

/**
 * Tr√≠ch xu·∫•t th√¥ng tin phi√™n b·∫£n h√≥a ƒë∆°n
 */
function extractInvoiceVersion(invoiceCode) {
  if (!invoiceCode) {
    return { isRevised: false, baseCode: invoiceCode, version: 0 };
  }

  // Ki·ªÉm tra m·∫´u .01, .02, ... ·ªü cu·ªëi m√£ h√≥a ƒë∆°n
  const regex = /^(.+)\.(\d+)$/;
  const match = invoiceCode.match(regex);

  if (match) {
    return {
      isRevised: true,
      baseCode: match[1], // M√£ g·ªëc kh√¥ng c√≥ .0x
      version: parseInt(match[2]), // Phi√™n b·∫£n (1, 2, ...)
    };
  } else {
    return { isRevised: false, baseCode: invoiceCode, version: 0 };
  }
}

/**
 * So s√°nh chi ti·∫øt gi·ªØa h√≥a ƒë∆°n g·ªëc v√† h√≥a ƒë∆°n ƒëi·ªÅu ch·ªânh
 */
function compareInvoiceDetails(originalInvoice, revisedInvoice) {
  try {
    const comparison = {
      addedProducts: [], // S·∫£n ph·∫©m c√≥ trong h√≥a ƒë∆°n ƒëi·ªÅu ch·ªânh nh∆∞ng kh√¥ng c√≥ trong h√≥a ƒë∆°n g·ªëc
      removedProducts: [], // S·∫£n ph·∫©m c√≥ trong h√≥a ƒë∆°n g·ªëc nh∆∞ng kh√¥ng c√≥ trong h√≥a ƒë∆°n ƒëi·ªÅu ch·ªânh
      quantityChanges: [], // S·∫£n ph·∫©m c√≥ thay ƒë·ªïi s·ªë l∆∞·ª£ng
      totalChanged: false, // ƒê√°nh d·∫•u c√≥ thay ƒë·ªïi t·ªïng ti·ªÅn
      oldTotal: null, // T·ªïng ti·ªÅn c≈©
      newTotal: null, // T·ªïng ti·ªÅn m·ªõi
      hasChanges: false, // ƒê√°nh d·∫•u c√≥ s·ª± kh√°c bi·ªát
    };

    // Ki·ªÉm tra thay ƒë·ªïi t·ªïng ti·ªÅn
    if (originalInvoice.total !== revisedInvoice.total) {
      comparison.totalChanged = true;
      comparison.oldTotal = originalInvoice.total;
      comparison.newTotal = revisedInvoice.total;
      comparison.hasChanges = true;
    }

    // Ki·ªÉm tra n·∫øu kh√¥ng c√≥ chi ti·∫øt h√≥a ƒë∆°n
    if (!originalInvoice.invoiceDetails || !revisedInvoice.invoiceDetails) {
      return comparison;
    }

    // T·∫°o map t·ª´ chi ti·∫øt h√≥a ƒë∆°n g·ªëc
    const originalDetailsMap = new Map();
    originalInvoice.invoiceDetails.forEach((detail) => {
      if (detail.productId) {
        originalDetailsMap.set(detail.productId, detail);
      }
    });

    // T·∫°o map t·ª´ chi ti·∫øt h√≥a ƒë∆°n ƒëi·ªÅu ch·ªânh
    const revisedDetailsMap = new Map();
    revisedInvoice.invoiceDetails.forEach((detail) => {
      if (detail.productId) {
        revisedDetailsMap.set(detail.productId, detail);
      }
    });

    // Ki·ªÉm tra s·∫£n ph·∫©m th√™m m·ªõi
    for (const [productId, revisedDetail] of revisedDetailsMap) {
      if (!originalDetailsMap.has(productId)) {
        comparison.addedProducts.push(revisedDetail);
        comparison.hasChanges = true;
      }
    }

    // Ki·ªÉm tra s·∫£n ph·∫©m b·ªã x√≥a
    for (const [productId, originalDetail] of originalDetailsMap) {
      if (!revisedDetailsMap.has(productId)) {
        comparison.removedProducts.push(originalDetail);
        comparison.hasChanges = true;
      }
    }

    // Ki·ªÉm tra s·∫£n ph·∫©m thay ƒë·ªïi s·ªë l∆∞·ª£ng
    for (const [productId, revisedDetail] of revisedDetailsMap) {
      if (originalDetailsMap.has(productId)) {
        const originalDetail = originalDetailsMap.get(productId);
        if (revisedDetail.quantity !== originalDetail.quantity) {
          comparison.quantityChanges.push({
            product: revisedDetail,
            originalQuantity: originalDetail.quantity,
            newQuantity: revisedDetail.quantity,
            difference: revisedDetail.quantity - originalDetail.quantity,
          });
          comparison.hasChanges = true;
        }
      }
    }

    return comparison;
  } catch (error) {
    console.error("‚ùå L·ªói khi so s√°nh chi ti·∫øt h√≥a ƒë∆°n:", error.message);
    return { hasChanges: false };
  }
}

/**
 * Ch·∫°y b√°o c√°o ngay l·∫≠p t·ª©c
 */
async function runReportNow() {
  console.log("üöÄ Ch·∫°y b√°o c√°o th·ªß c√¥ng...");
  try {
    // C·∫≠p nh·∫≠t d·ªØ li·ªáu ƒë∆°n h√†ng trong 14 ng√†y
    await fetchAndStoreOrdersForLast14Days();

    // L·∫•y t·∫•t c·∫£ c√°c ƒë∆°n h√†ng ƒë√£ l∆∞u
    const allSavedOrders = await getAllSavedOrders();
    console.log(
      `üìä ƒê√£ t·∫£i ${allSavedOrders.length} ƒë∆°n h√†ng ƒë√£ l∆∞u ƒë·ªÉ so s√°nh`
    );

    // L·ªçc c√°c ƒë∆°n h√†ng ·ªü tr·∫°ng th√°i "Phi·∫øu t·∫°m" (status=1), "ƒê√£ x√°c nh·∫≠n" (status=2) ho·∫∑c "ƒê√£ h·ªßy" (status=3)
    const validOrders = allSavedOrders.filter(
      (order) => order.status === 1 || order.status === 2 || order.status === 3
    );
    console.log(
      `üîç ƒê√£ l·ªçc ${validOrders.length} ƒë∆°n h√†ng v·ªõi tr·∫°ng th√°i h·ª£p l·ªá t·ª´ d·ªØ li·ªáu ƒë√£ l∆∞u`
    );

    // L·∫•y danh s√°ch h√≥a ƒë∆°n hi·ªán t·∫°i
    const currentInvoices = await invoiceScanner.getRecentInvoices();
    console.log(`üìä ƒê√£ l·∫•y ${currentInvoices.length} h√≥a ƒë∆°n t·ª´ KiotViet`);

    // So s√°nh ƒë∆°n h√†ng v·ªõi h√≥a ƒë∆°n
    const orderInvoiceComparisons = compareOrdersWithInvoices(
      validOrders,
      currentInvoices
    );

    // G·ª≠i th√¥ng b√°o cho c√°c so s√°nh c√≥ s·ª± kh√°c bi·ªát
    if (orderInvoiceComparisons.length > 0) {
      console.log(
        `üîî T√¨m th·∫•y ${orderInvoiceComparisons.length} ƒë∆°n h√†ng c√≥ s·ª± kh√°c bi·ªát so v·ªõi h√≥a ƒë∆°n`
      );

      for (const comparison of orderInvoiceComparisons) {
        try {
          await lark.sendOrderInvoiceComparisonReport(comparison);
          console.log(
            `‚úÖ ƒê√£ g·ª≠i b√°o c√°o so s√°nh cho ƒë∆°n h√†ng ${comparison.order.code} v√† h√≥a ƒë∆°n ${comparison.invoice.code}`
          );
        } catch (err) {
          console.error(
            `‚ùå L·ªói g·ª≠i b√°o c√°o so s√°nh cho ƒë∆°n h√†ng ${comparison.order.code}:`,
            err.message
          );
        }
      }
    } else {
      console.log("‚úÖ Kh√¥ng t√¨m th·∫•y s·ª± kh√°c bi·ªát gi·ªØa ƒë∆°n h√†ng v√† h√≥a ƒë∆°n");
    }

    // So s√°nh h√≥a ƒë∆°n g·ªëc v·ªõi c√°c phi√™n b·∫£n ƒëi·ªÅu ch·ªânh
    const invoiceVersionComparisons = compareInvoiceVersions(currentInvoices);

    // G·ª≠i th√¥ng b√°o cho c√°c so s√°nh c√≥ s·ª± kh√°c bi·ªát
    if (invoiceVersionComparisons.length > 0) {
      console.log(
        `üîî T√¨m th·∫•y ${invoiceVersionComparisons.length} h√≥a ƒë∆°n ƒëi·ªÅu ch·ªânh c√≥ s·ª± kh√°c bi·ªát`
      );

      for (const comparison of invoiceVersionComparisons) {
        try {
          await lark.sendInvoiceVersionComparisonReport(comparison);
          console.log(
            `‚úÖ ƒê√£ g·ª≠i b√°o c√°o so s√°nh cho h√≥a ƒë∆°n ${comparison.originalInvoice.code} v√† phi√™n b·∫£n ƒëi·ªÅu ch·ªânh ${comparison.revisedInvoice.code}`
          );
        } catch (err) {
          console.error(
            `‚ùå L·ªói g·ª≠i b√°o c√°o so s√°nh cho h√≥a ƒë∆°n ${comparison.originalInvoice.code}:`,
            err.message
          );
        }
      }
    } else {
      console.log("‚úÖ Kh√¥ng t√¨m th·∫•y s·ª± kh√°c bi·ªát gi·ªØa c√°c phi√™n b·∫£n h√≥a ƒë∆°n");
    }

    // C·∫≠p nh·∫≠t file lastOrders.json ƒë·ªÉ t∆∞∆°ng th√≠ch ng∆∞·ª£c
    saveCurrentData(validOrders);

    return {
      success: true,
      message: "B√°o c√°o ƒë√£ ƒë∆∞·ª£c th·ª±c thi th√†nh c√¥ng",
    };
  } catch (error) {
    console.error("‚ùå L·ªói khi ch·∫°y b√°o c√°o th·ªß c√¥ng:", error.message);
    return {
      success: false,
      message: error.message,
    };
  }
}

module.exports = {
  setupPeriodicCheck,
  runReportNow,
};
